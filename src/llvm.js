var exports = module.exports = {};

exports.compile = compile;

function compile(program, className) {
  var compiled = _compile(program);

  compiled.code = generateHeader(className);
  compiled.code += generateMain(compiled);

  return compiled;
}



function _compile(program) {
  var compiled = {
    mainCode: [],
    locals: program.locals,
    stack: 0
  }
  var env = program.env;
  var labelsCount = 0;
  var key;

  for (key in env) {
    compiled.mainCode.push('%' + key + ' = alloca i32');
  }

  for (var i = 0; i < program.lines.length; i++) {
    var line = compileNode(program.lines[i]);

    compiled.mainCode.push('; line ' + (i+1));
    compiled.mainCode.push(line.code);
  }

  compiled.mainCode.push('ret i32 0');

  return compiled;

  function compileNode(node) {
    var code = [];
    var tmpCode = '';
    var left;
    var right;
    var label;

    if (node.nodeType === 'stmt') {
      tmpCode += 'store i32 ';
      if (node.right.nodeType === 'number') {
        tmpCode += node.right.value + ', ';
      } else {
        right = compileNode(node.right);
        code = code.concat(right.code);
        tmpCode += right.label + ', ';
      }

      tmpCode += 'i32* %' + node.left.value;
      code.push(tmpCode);
    } else if (node.nodeType === 'exp') {
      if (node.value === '-') {
        tmpCode += 'sub i32 ';
      } else if (node.value === '/') {
        tmpCode += 'div i32 ';
      } else if (node.value === '*') {
        tmpCode += 'mul i32 ';
      } else if (node.value === '+') {
        tmpCode += 'add i32 ';
      }

      if (node.left.nodeType === 'number') {
        tmpCode += node.left.value + ', ';
      } else {
        left = compileNode(node.left);
        code = code.concat(left.code);
        tmpCode += left.label + ', ';
      }

      if (node.right.nodeType === 'number') {
        tmpCode += node.right.value;
      } else {
        right = compileNode(node.right);
        code = code.concat(right.code);
        tmpCode += right.label;
      }

      label = '%t' + labelsCount++;
      tmpCode = label + ' = ' + tmpCode;

      code.push(tmpCode);
    } else if (node.nodeType === 'string') {
      label = '%t' + labelsCount++;
      code.push(label + ' = load i32* %' + node.value);
    } else if (node.nodeType === 'number') {
      label = '%t' + labelsCount++;
      code.push(label + ' = add i32 0, ' + node.value);
    }

    return {
      code: code,
      label: label
    }
  }
}

function generateHeader() {
  var header = '';

  header += '; Generated by visual-compiler Â®Jakub Rohleder\n';
  header += '; https://github.com/jakubrohleder/visual-compiler\n';
  header += '; (LLVM syntax, http://llvm.org/docs/LangRef.html)\n\n';

  return header;
}

function generateMain(compiled) {
  var main = '';

  main += 'define i32 @main() {\n';

  main += indentLines(compiled.mainCode, 1).join('\n');

  main += '\n}\n';

  return main;
}

function indentLines(array, indentation) {
  indentation = indentation === undefined ? 0 : indentation;
  return array.reduce(reduce, []);

  function reduce(accumulator, element) {
    if (element instanceof Array) {
      var tmp = indentLines(element, indentation + 1);
      return accumulator.concat(tmp);
    } else {
      var indent = new Array(indentation + 1).join('  ');
      accumulator.push(indent + element);
      return accumulator;
    }
  }
}
{
  "bad": {
    "bad001.lat": "// Not closed comment block\n/*\n",
    "bad002.lat": "// Wat?\na\n",
    "bad003.lat": "// Repeated argument name\nint main() {\n   return f(1, 1);\n}\n\nint f(int x, int x) {\n  return 1;\n}",
    "bad004.lat": "// Double return\nint main() {\n        return 0;\n        return 1;\n}\n",
    "bad005.lat": "// Function with no type\nfoo() {}\n",
    "bad006.lat": "//Assigment to undeclared variable\nint main() {\n        x = 14;\n\treturn 0 ;\n}\n",
    "bad007.lat": "//Variable redeclaration\nint main() {\n        int x;\n        int x;\n\treturn 0 ;\n}\n",
    "bad008.lat": "//Path with no return\n  int main() {\n    if (false)\n       return 0;\n}\n",
    "bad009.lat": "// boolean to int assigment\nint main() {\n        int x;\n        x = true;\n        return 1;\n}\n",
    "bad010.lat": "// return with no value for int function\nint main() {\n        if (true)\n                return;\n\t;\n        return 1;\n}\n",
    "bad011.lat": "// boolean return for int function\nint main() {\n     return true;\n}\n",
    "bad012.lat": "// function with no return\nint main() {\n     int i = foo(true);\n     return 0 ;\n}\n\nint foo(boolean b) { b = true; }\n",
    "bad013.lat": "// Adding int to string\nint main() {\n      string x ;\n      x = \"pi\" + 1 ;\n      return 0 ;\n}\n",
    "bad015.lat": "// passing string to printInt().\n\nint main() {\n\tprintInt(\"foo\");\n\treturn 0 ;\n}\n",
    "bad016.lat": "// passing integers to printString().\n\nint main() {\n\tprintString(1);\n\treturn 0 ;\n}\n",
    "bad017.lat": "// 0 instead of 1 argument\n\nint main() {\n\tint x = foo();\n\treturn 0 ;\n}\n\nint foo(int y) {\n return y;\n}\n\n",
    "bad018.lat": "// 1 instead of 2 arguments\n\nint main() {\n\tint x = foo(1);\n\treturn 0 ;\n}\n\nint foo(int y,int z) {\n return y;\n}\n\n",
    "bad019.lat": "// 2 instead of 1 arguments\n\nint main() {\n\tint x = foo(1,2);\n\treturn 0 ;\n}\n\nint foo(int y) {\n return y;\n}\n\n",
    "bad020.lat": "// Compare string with boolean.\n\nint main() {\n  if (\"true\" == true) {\n   printString(\"foo\");\n  }\n  return 0 ;\n}",
    "bad021.lat": "/* Testing that main must return. */\n\n/* All functions should return a value of their value type. This is not a valid Javalette program: */\n\nint main() {\n}\n",
    "bad022.lat": "// Assigning string to int variable.\n\nint main () {\n int x = \"\";\n return 0 ;\n}",
    "bad023.lat": "// Assigning int to string variable.\n\nint main () {\n string x = 1;\n return 0 ;\n}",
    "bad024.lat": "// Path with no return\nint main() {\n    if (false)\n       return 0;\n}\n",
    "bad025.lat": "// Path with no return\nint main() {\n   return f(3);\n}\n\nint f(int x) {\n    if (x<0)\n       return x;\n}\n",
    "bad026.lat": "// Assigning string to int variable.\n\nint main () {\n int x;\n  x = \"foo\"+\"bar\";\n return 0 ;\n}",
    "bad027.lat": "// Assigning int to string variable.\n\nint main () {\n string x;\n x = 1;\n return 0 ;\n}",
    "bad028.lat": "// Variable declaration as an only if instruction\n\nint main () {\n if(true)\n    1+1;\n  else\n    int x;\n return 0 ;\n}",
    "bad029.lat": "// Using variable declared in if block\n\nint main () {\n if(true) {\n    int x;\n }\n x = 10;\n return 0 ;\n}",
    "bad030.lat": "//Function redeclaration\nint main() {\n  int x;\n  int x;\n\treturn 0 ;\n}\n\nint f() {\n  return 0;\n}\n\nint f() {\n  return 0;\n}",
    "bad031.lat": "// Variable declaration as an only while instruction\n\nint main () {\n  while(true)\n    int x;\n return 0 ;\n}",
    "bad032.lat": "// Using variable declared in while\n\nint main () {\n  while(true) {\n    int x;\n  }\n\n  x = 1;\n return 0 ;\n}"
  },
  "mine": {
    "array_length.lat": "int main() {\n\n  int[] i = new int[20];\n\n  printInt(i.length);\n  printInt(i.references);\n\n  i = new int[10];\n\n  printInt(i.length);\n  printInt(i.references);\n\n  int j=0;\n\n  while (j<i.length) {\n    i[j] = j;\n    j++;\n  }\n\n  for (int x : i)\n    printInt(x);\n\n  return 0;\n}",
    "string_length.lat": "int main() {\n\n  string s = \"1234\";\n\n  string s2 = s + \"56789\";\n\n  printString(s);\n  printInt(s.length);\n  printInt(s.references);\n\n  printString(s2);\n  printInt(s2.length);\n  printInt(s2.references);\n\n  string s3;\n  s3 = s2 + readString();\n\n  printString(s3);\n  printInt(s3.length);\n  printInt(s3.references);\n\n  return 0;\n}"
  },
  "good": {
    "core000.lat": "int main() {\n  printInt(1);\n\tprintInt(2);\n  test();\n  printInt(5);\n  return 0;\n}\n\nint test() {\n  printInt(3);\n  error();\n  printInt(4);\n  return 0;\n}",
    "core001.lat": "int main() {\n\tprintInt(fac(10));\n\tprintInt(rfac(10));\n\tprintInt(mfac(10));\n        printInt(ifac(10));\n        string r ; // just to test blocks \n\t{\n\t  int n = 10;\n\t  int r = 1;\n\t  while (n>0) {\n\t    r = r * n;\n\t    n--;\n\t  }\n\t  printInt(r);\n\t}\n\tprintString (repStr(\"=\",60));\n\tprintString (\"hello */\");\n        printString (\"/* world\") ;\n        return 0 ;\n}\n\nint fac(int a) {\n\tint r;\n\tint n;\n\n\tr = 1;\n\tn = a;\n\twhile (n > 0) {\n\t  r = r * n;\n\t  n = n - 1;\n\t}\n\treturn r;\n}\n\nint rfac(int n) {\n\tif (n == 0)\n\t  return 1;\n\telse\n\t  return n * rfac(n-1);\n}\n\nint mfac(int n) {\n\tif (n == 0)\n\t  return 1;\n\telse\n\t  return n * nfac(n-1);\n}\n\nint nfac(int n) {\n\tif (n != 0)\n\t  return mfac(n-1) * n;\n\telse\n\t  return 1;\n}\n\nint ifac(int n) { return ifac2f(1,n); }\n\nint ifac2f(int l, int h) {\n        if (l == h)\n          return l;\n        if (l > h)\n          return 1;\n        int m;\n        m = (l + h) / 2;\n        return ifac2f(l,m) * ifac2f(m+1,h);\n}\n\nstring repStr(string s, int n) {\n  string r = \"\";\n  int i = 0;\n  while(i<n) {\n    r = r + s;\n    i++;\n  }\n return r;\n}",
    "core002.lat": "/* void expression as statement */\n\nint main() {\n  foo();\n  return 0 ;\n\n}\n\nvoid foo() {\n   printString(\"foo\");\n   return;\n}\n",
    "core003.lat": "// Testing the return checker\n\nint f () {\n   if (true)\n     return 0;\n   else\n     {}\n}\n\nint g () {\n  if (false) \n      {}\n  else\n      return 0;\n}\n\nvoid p () {}\n  \n\nint main() {\n  p();\n  return 0;\n}\n",
    "core004.lat": "/* allow comparing booleans. */\n\nint main() {\n  if (true == true) { printInt(42); }\n  return 0 ;\n\n}",
    "core005.lat": "/* usage of variable initialized in both branches. */\n\nint main () {\n  int x;\n  int y = 56;\n  if (y + 45 <= 2) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n  printInt(x);\n  return 0 ;\n\n}",
    "core006.lat": "// Declaration of multiple variables of the same type in one statement:\n\nint main () {\n  int x, y;\n  x = 45;\n  y = -36;\n  printInt(x);\n  printInt(y);\n  return 0 ;\n\n}",
    "core007.lat": "// declaration and initialization in same statement\n\nint main() {\n int x = 7;\n printInt(x);\n return 0 ;\n\n}",
    "core008.lat": "// multiple variables of the same type declared \n// and possibly initialized in the same statement\n\nint main() {\n int x, y = 7;\n x = -1234234;\n printInt(x);\n printInt(y);\n return 0 ;\n\n}",
    "core009.lat": "// Calling functions which take zero parameters\n\nint main() {\n int x = foo();\n printInt(x);\n return 0 ;\n\n}\n\nint foo() {\n return 10;\n}\n\n",
    "core010.lat": "// count function parameters as initialized\n\nint main() {\n  printInt(fac(5));\n  return 0 ;\n}\n\nint fac (int a) {\n  int r;\n  int n;\n  r = 1;\n  n = a;\n  while (n > 0)\n  {\n    r = r * n;\n    n = n - 1;\n  }\n  return r;\n}\n",
    "core011.lat": "/* Test pushing -1. */\n\nint main() {\n  printInt(-1);\n  return 0 ;\n}",
    "core012.lat": "/* Test arithmetic and comparisons. */\n\nint main() {\n    int x = 56;\n    int y = -23;\n    printInt(x+y);\n    printInt(x-y);\n    printInt(x*y);\n    printInt(45/2);\n    printInt(78%3);\n    printBool(x-y > x+y);\n    printBool(x/y <= x*y);\n    printString(\"string\"+\" \"+\"concatenation\");\n    return 0 ;\n}\n\nvoid printBool(boolean b) {\n  if (b) {\n    printString(\"true\");\n    return;\n  } else {\n    printString(\"false\");\n    return;\n }\n}",
    "core013.lat": "/* Test boolean operators. */\n\nint main() {\n  printString(\"&&\");\n  printBool(test(-1) && test(0));\n  printBool(test(-2) && test(1));\n  printBool(test(3) && test(-5));\n  printBool(test(234234) && test(21321));\n  printString(\"||\");\n  printBool(test(-1) || test(0));\n  printBool(test(-2) || test(1));\n  printBool(test(3) || test(-5));\n  printBool(test(234234) || test(21321));\n  printString(\"!\");\n  printBool(true);\n  printBool(false);\n  return 0 ;\n\n}\n\nvoid printBool(boolean b) {\n  if (!b) {\n    printString(\"false\");\n  } else {\n    printString(\"true\");\n }\n return;\n}\n\nboolean test(int i) {\n  printInt(i);\n  return i > 0;\n}",
    "core014.lat": "/* Fibonacci. */\n\nint main () {\n  int lo,hi,mx ;\n  lo = 1 ;\n  hi = lo ;\n  mx = 5000000 ;\n  printInt(lo) ;\n  while (hi < mx) {\n    printInt(hi) ;\n    hi = lo + hi ;\n    lo = hi - lo ;\n  }\n  return 0 ;\n\n}\n\n",
    "core015.lat": "/* parity of positive integers by recursion */\n\nint main () {\n  printInt(ev(17)) ;\n  return 0 ;\n}\n\nint ev (int y) {\n  if (y > 0)\n    return ev (y-2) ;\n  else\n    if (y < 0)\n      return 0 ;\n    else\n      return 1 ;\n}",
    "core016.lat": "/* parity of positive integers by loop */\n\nint main () {\n  int y = 17;\n  while (y > 0)\n    y = y - 2;\n  if (y < 0) {\n    printInt(0);\n    return 0 ;\n    }\n  else {\n    printInt(1);\n    return 0 ;\n    }\n}\n",
    "core017.lat": "/* Test boolean operators */\n\nint main () {\n  int x = 4;\n  if (3 <= x && 4 != 2 && true) {\n    printBool(true);\n  } else {\n    printString(\"apa\");\n  }\n\n  printBool(true == true || dontCallMe(1));\n  printBool(4 < -5 && dontCallMe(2));\n\n  printBool(4 == x && true == !false && true);\n\n  printBool(implies(false,false));\n  printBool(implies(false,true));\n  printBool(implies(true,false));\n  printBool(implies(true,true));\n  return 0 ;\n\n}\n\nboolean dontCallMe(int x) {\n  printInt(x);\n  return true;\n}\n\nvoid printBool(boolean b) {\n  if (b) {\n    printString(\"true\");\n  } else {\n    printString(\"false\");\n }\n return;\n}\n\nboolean implies(boolean x, boolean y) {\n  return !x || x == y;\n}\n",
    "core018.lat": "/* test input */\n\nint main() {\n  int x = readInt();\n  string y = readString();\n  string z = readString();\n\n  printInt(x-5);\n  printString(y+z);  \n  return 0 ;\n}",
    "core019.lat": "int main() {\n  int i = 78;\n  {\n    int i = 1;\n    printInt(i);\n  }\n  printInt(i);\n  while (i > 76) {\n    i--;\n    printInt(i);\n   // this is a little tricky\n   // on the right hand side, i refers to the outer i\n   int i = i + 7;\n   printInt(i);\n  }\n  printInt(i);\n  if (i > 4) {\n    int i = 4;\n    printInt(i);\n  } else {\n    printString(\"foo\");\n  } \n  printInt(i);\n  return 0 ;\n\n}",
    "core020.lat": "int main() {\n    p();\n    printInt(1);\n    return 0;\n}\n\nvoid p() {}\n",
    "core021.lat": "int main() {\n    if (true) {\n      printInt(1);\n      return 0;\n    }\n}",
    "core022.lat": "int main() {\n    int x;\n    printInt(x);\n    return 0;\n}\n"
  },
  "extensions": {
    "objects1": {
      "counter.lat": "int main () {\n  Counter c;\n  c = new Counter;\n  c.incr();\n  c.incr();\n  c.incr();\n  int x = c.value();\n  printInt(x);\n  return 0;\n}\n\nclass Counter {\n  int val;\n\n  void incr () {val++; return;}\n\n  int value () {return val;}\n\n}\n",
      "linked.lat": "class Node {\n  int elem;\n  Node next;\n\n  void setElem(int c) { elem = c; }\n\n  void setNext(Node n) { next = n; }\n\n  int getElem() { return elem; }\n\n  Node getNext() { return next; }\n}\n\nclass Stack {\n  Node head;\n\n  void push(int c) {\n    Node newHead = new Node;\n    newHead.setElem(c);\n    newHead.setNext(head);\n    head = newHead;\n  }\n\n  boolean isEmpty() {\n    return head==null;\n  }\n\n  int top() {\n    return head.getElem();\n  }\n\n  void pop() {\n    head = head.getNext();\n  }\n}\n\nint main() {\n   Stack s = new Stack;\n   int i= 0;\n   while (i<10) {\n     s.push(i);\n     i++;\n   }\n\n   while (!s.isEmpty()) {\n     printInt(s.top());\n     s.pop();\n   }\n   return 0;\n}\n",
      "points.lat": "class Point2 {\n  int x;\n  int y;\n\n  void move (int dx, int dy) {\n     x = x + dx;\n     y = y + dy;\n  }\n\n  int getX () { return x; }\n\n  int getY () { return y; }\n}\n\nclass Point3 extends Point2 {\n  int z;\n\n  void moveZ (int dz) {\n    z = z + dz;\n  }\n\n  int getZ () { return z; }\n\n}\n\nclass Point4 extends Point3 {\n  int w;\n\n  void moveW (int dw) {\n    w = w + dw;\n  }\n\n  int getW () { return w; }\n\n}\n\n\n\nint main () {\n  Point2 p = new Point3;\n\n  Point3 q = new Point3;\n\n  Point4 r = new Point4;\n\n  q.move(2,4);\n  q.moveZ(7);\n  p = q;\n\n  p.move(3,5);\n \n  r.move(1,3);\n  r.moveZ(6);\n  r.moveW(2);\n\n  printInt(p.getX());  \n  printInt(p.getY());  \n  printInt(q.getZ());  \n  printInt(r.getW());\n  return 0;\n\n}",
      "queue.lat": "class Node {\n  int elem;\n  Node next;\n\n  void setElem (int e)  { elem = e; }\n  void setNext (Node n) { next = n; }\n\n  int  getElem () { return elem; }\n  Node getNext () { return next; }\n\n}\n\nclass IntQueue {\n  Node front;\n  Node rear;\n\n  boolean isEmpty () { return front == null; }\n\n  void insert (int x) {\n    Node last = new Node;\n    last.setElem(x);\n    if (self.isEmpty())\n      front = last;\n    else\n      rear.setNext(last);\n    rear = last;\n  }\n\n  int first () { return front.getElem(); }\n\n  void rmFirst () {\n    front = front.getNext();\n  }\n\n  int size () {\n      Node n = front;\n      int res = 0;\n      while (n != null) {\n        n = n.getNext();\n        res++;\n      }\n     return res;\n  }\n}\n\nint f (int x) {\n  return x*x + 3;\n}\n\nint main () {\n  IntQueue q = new IntQueue;\n  q.insert(f(3));\n  q.insert(5);\n  q.insert(7);\n  printInt(q.first());\n  q.rmFirst();\n  printInt(q.size());\n  return 0;\n}\n\n"
    },
    "arrays1": {
      "array000.lat": "int main() {\n  int[] a = new int[20];\n  a[10] = 1;\n  a[11] = 2;\n  printInt(a[10]);\n  printInt(a[11]);\n\n  return 0;\n}",
      "array001.lat": "int main() {\n\n  int[] a = new int[10];\n  int j=0;\n  while (j<a.length) {\n     a[j] = j;\n     j++;\n  }\n\n  for (int x : a)\n     printInt(x);\n\n  int x = 45;\n  printInt(x);\n  return 0;\n}",
      "array002.lat": "int [] doubleArray (int [] a){\n  int [] res = new int [a . length];\n  int i = 0 ;\n  for (int n : a){\n    res [i] = 2 * n ;\n    i ++ ;\n  }\n  return res ;\n}\n\nvoid shiftLeft (int [] a){\n  int x = a [0];\n  int i = 0 ;\n  while (i < a.length - 1){\n    a [i] = a [i + 1];\n    i ++ ;\n  }\n  a[a.length - 1]= x ;\n  return;\n }\n\nint scalProd(int[] a, int[] b) {\n  int res = 0;\n  int i = 0;\n  while (i < a.length) {\n    res = res + a[i] * b[i];\n    i++;\n  }\n  return res;\n}\n\nint main () {\n  int [] a = new int [5];\n  int i = 0 ;\n  while (i < a.length){\n    a [i]= i ;\n    i ++ ;\n    }\n  shiftLeft (a);\n  int [] b = doubleArray (a);\n  for (int x : a)printInt (x);\n  for (int x : b)printInt (x);\n  printInt(scalProd(a,b));\n  return 0 ;\n}\n "
    },
    "objects2": {
      "shapes.lat": "class Node {\n  Shape elem;\n  Node next;\n\n  void setElem(Shape c) { elem = c; }\n\n  void setNext(Node n) { next = n; }\n\n  Shape getElem() { return elem; }\n\n  Node getNext() { return next; }\n}\n\nclass Stack {\n  Node head;\n\n  void push(Shape c) {\n    Node newHead = new Node;\n    newHead.setElem(c);\n    newHead.setNext(head);\n    head = newHead;\n  }\n\n  boolean isEmpty() {\n    return head==null;\n  }\n\n  Shape top() {\n    return head.getElem();\n  }\n\n  void pop() {\n    head = head.getNext();\n  }\n}\n\nclass Shape {\n  void tell () {\n    printString(\"I'm a shape\");\n  }\n\n  void tellAgain() {\n     printString(\"I'm just a shape\");\n  }\n}\n\nclass Rectangle extends Shape {\n  void tellAgain() {\n    printString(\"I'm really a rectangle\");\n  }\n}\n\nclass Circle extends Shape {\n  void tellAgain() {\n    printString(\"I'm really a circle\");\n  }\n}\n\nclass Square extends Rectangle {\n  void tellAgain() {\n    printString(\"I'm really a square\");\n  }\n}\n\nint main() {\n  Stack stk = new Stack;\n  Shape s = new Shape;\n  stk.push(s);\n  s = new Rectangle;\n  stk.push(s);\n  s = new Square;\n  stk.push(s);\n  s = new Circle;\n  stk.push(s);\n  while (!stk.isEmpty()) {\n    s = stk.top();\n    s.tell();\n    s.tellAgain();\n    stk.pop();\n  }\n  return 0;\n}\n"
    },
    "struct": {
      "list.lat": "class list {\n  int elem;\n  list next;\n}\n\nint main() {\n  printInt(length(fromTo(1,50)));\n  printInt(length2(fromTo(1,100)));\n  return 0;\n}\n\nint head (list xs) {\n  return xs . elem;\n}\n\nlist cons (int x, list xs) {\n  list n;\n  n = new list;\n  n.elem = x;\n  n.next = xs;\n  return n;\n}\n\nint length (list xs) {\n  if (xs==null)\n    return 0;\n  else\n    return 1 + length (xs.next);\n}\n\nlist fromTo (int m, int n) {\n  if (m>n)\n    return null;\n  else\n    return cons (m,fromTo (m+1,n));\n}\n\nint length2 (list xs) {\n  int res = 0;\n  while (xs != null) {\n    res++;\n    xs = xs.next;\n  }\n  return res;\n}\n"
    }
  },
  "extra": {
    "gr5": {
      "bfs.lat": "/******************************************************************\n *                                                                *\n * bfs test by Michał Gregorczyk (mg277528@students.mimuw.edu.pl) *\n *                               (michalg89@gmail.com)            *\n *                                                                *\n ******************************************************************\n * 22. stycznia 12:00                                             *\n *                                                                *\n * Mój kompilator jeszcze nie potrafi                             *\n * skompilować tego testu, dlatego                                *\n * nie sprawidziłem jego poprawności.                             *\n * Test przechodzi natomiast przez                                *\n * analizę semantyczną.                                           *\n *                                                                *\n * Będę wdzięczny za wszelkie uwagi                               *\n * typu \"nie działa, daje zły wynik\"                              *\n * lub \"u mnie działa\".                                           *\n *****************************************************************/\n\nclass Node{\n    boolean visited;\n    int value;\n    List neighbours;\n\n    void init(int val){\n        visited = false;\n        value = val;\n        neighbours = null;    \n    }\n\n    boolean isVisited(){\n        return visited;\n    }\n\n    void markAsVisited(){\n        visited = true;\n    }\n\n    int getValue(){\n        return value;\n    }\n\n    List getNeighbours(){\n        return neighbours;\n    }\n\n    void addNeighbour(Node n){\n        if (neighbours == null){\n            neighbours = new List;\n            neighbours.makeSingleton(n);\n        }\n        else{\n            List newNeighbours = new List;\n            newNeighbours.cons(n, neighbours);\n            neighbours = newNeighbours;\n        }\n    }\n}\n\nclass List{\n    Node head;\n    List tail;\n\n    void makeSingleton(Node node){\n        head = node;\n        tail = null;\n    }\n\n    Node getHead(){\n        return head;\n    }\n\n    List getTail(){\n        return tail;\n    }\n\n    void cons(Node newHead, List newTail){\n        self.head = newHead;\n        self.tail = newTail;\n    }\n}\n\nclass Queue{\n    List first;\n    List last;\n\n    Node get(){\n        if (first == null)\n            return null;\n\n        Node retEl = first.head;\n\n        first = first.tail;\n        if (first == null)\n            last = null;\n\n        return retEl;\n    }\n\n    void put(Node n){\n        List newTail = new List;\n        newTail.makeSingleton(n);\n        if (first == null){\n            first = newTail;\n            last = newTail;\n        }\n        else{\n            last.cons(last.getHead(), newTail);\n            last = newTail;\n        }\n    }\n\n    boolean isEmpty(){\n        return (first == null);\n    }\n}\n\nint main(){\n    Node graph = prepareData();\n    graph.markAsVisited();\n    Queue q = new Queue;\n    q.put(graph);\n    bfs(q);\n    return 0;\n}\n\nNode prepareData(){\n    Node n1 = new Node;\n    n1.init(1);\n    Node n2 = new Node;\n    n2.init(2);\n    Node n3 = new Node;\n    n3.init(3);\n    Node n4 = new Node;\n    n4.init(4);\n    Node n5 = new Node;\n    n5.init(5);\n    Node n6 = new Node;\n    n6.init(6);\n    Node n7 = new Node;\n    n7.init(7);\n    Node n8 = new Node;\n    n8.init(8);\n    Node n9 = new Node;\n    n9.init(9);\n\n    n1.addNeighbour(n3);\n    n1.addNeighbour(n2);\n    \n    n2.addNeighbour(n3);\n\n    n3.addNeighbour(n6);\n    n3.addNeighbour(n5);\n    n3.addNeighbour(n4);\n\n    n4.addNeighbour(n2);\n\n    n5.addNeighbour(n7);\n\n    n7.addNeighbour(n8);\n\n    n8.addNeighbour(n9);\n\n    n9.addNeighbour(n5);\n\n    return n1;\n}\n\nvoid bfs(Queue q){\n    while (! q.isEmpty()){\n        Node el = q.get();\n        printInt(el.getValue());\n        List neigh = el.getNeighbours();\n        while(neigh != null){\n            Node n = neigh.getHead();\n            if (!n.isVisited()){\n                n.markAsVisited();\n                q.put(n);\n            }\n            neigh = neigh.getTail();\n        }\n    }\n}",
      "calculator.lat": "int main() {\n    Node w = plus(minus(liczba(4), liczba(3)), razy(liczba(2), podziel(liczba(4), liczba(2))));\n    printInt(w.value());\n    return 0;\n}\n\nNode plus(Node n1, Node n2) {\n    Operator res = new Plus;\n    res.left = n1;\n    res.right = n2;\n    return res;\n}\nNode razy(Node n1, Node n2) {\n    Operator res = new Razy;\n    res.left = n1;\n    res.right = n2;\n    return res;\n}\nNode podziel(Node n1, Node n2) {\n    Operator res = new Podziel;\n    res.left = n1;\n    res.right = n2;\n    return res;\n}\nNode minus(Node n1, Node n2) {\n    Operator res = new Minus;\n    res.left = n1;\n    res.right = n2;\n    return res;\n}\nNode liczba(int l) {\n    Liczba res = new Liczba;\n    res.v = l;\n    return res;\n}\n\nclass Node {\n    int value() {\n        error();\n        return 0;\n    }\n}\n\nclass Liczba extends Node {\n    int v;\n    int value() {\n        return v;\n    }\n}\n\nclass Operator extends Node {\n    Node left;\n    Node right;\n\n    int operator(int n1, int n2) {\n        error();\n        return 0;\n    }\n    int value() {\n        return self.operator(left.value(), right.value());\n    }\n}\n\nclass Plus extends Operator {\n    int operator(int a, int b) {\n        return a + b;\n    }\n}\n\nclass Minus extends Operator {\n    int operator(int a, int b) {\n        return a - b;\n    }\n}\n\nclass Razy extends Operator {\n    int operator(int a, int b) {\n        return a * b;\n    }\n}\n\nclass Podziel extends Operator {\n    int operator(int a, int b) {\n        return a / b;\n    }\n}\n",
      "heapsort.lat": "// Program zaliczeniowy 3: \"tablice - heap sort\"\n// autor: Bolek Kulbabinski\n//   Wejscie: dlugosc tablicy n > 0 po czym n liczb calkowitych.\n//   Wyjscie: n liczb w kolejnosci niemalejacej\n\nvoid swap(int[] tab, int x, int y) {\n    int temp = tab[x];\n    tab[x] = tab[y];\n    tab[y] = temp;\n}\n\n// Poprawienie kopca typu max.\nvoid heapDown(int[] heap, int index, int heapSize) {\n    while (index * 2 < heapSize - 1) {\n        int left = index * 2 + 1;\n        int right = left + 1;\n        int max = left;\n        if (right < heapSize && heap[right] > heap[max]) {\n            max = right;\n        }\n        if (heap[max] > heap[index]) {\n            swap(heap, max, index);\n            index = max;\n        } else {\n            return;\n        }\n    }\n}\n\nint extractMax(int[] heap, int heapSize) {\n    int max = heap[0];\n    heap[0] = heap[heapSize - 1];\n    heapDown(heap, 0, heapSize - 1);\n    return max;\n}\n\nvoid heapSort(int[] heap) {\n    // Budowanie kopca.\n    int i = heap.length / 2;\n    while (i >= 0) {\n        heapDown(heap, i, heap.length);\n        i--;\n    }\n\n    // Sortowanie.\n    i = heap.length - 1;\n    while (i >= 0) {\n        heap[i] = extractMax(heap, i + 1);\n        i--;\n    }\n}\n\nint main() {\n    int n = readInt();\n    int[] tab = new int[n];\n\n    int i = 0;\n    while (i < n) {\n        tab[i] = readInt();\n        i++;\n    }\n\n    heapSort(tab);\n\n    for (int elem : tab) {\n        printInt(elem);\n    }\n\n    return 0;\n}\n\n",
      "heapsort2.lat": "// Author: Robert Rosolek 277585\r\n//\r\n// input is in format :\r\n// n    <-- number of elements to sort\r\n// a_1\r\n// ...       <-- elements to sort\r\n// a_n\r\n//\r\n// code based on wazniak.mimuw.edu.pl\r\n\r\n// assuming that a[p + 1] ... a[r] is a heap,\r\n// this function makes a[p] ... a[r] a heap \r\nvoid maxHeapify(int[] a, int p, int r) {\r\n\tint s = p, v = a[s];\r\n\twhile (2 * s <= r) {\r\n\t\tint t = 2 * s;\r\n\t\tif (t < r)\r\n\t\t\tif (a[t + 1] > a[t])\r\n\t\t\t\tt++;\r\n\t\tif (v >= a[t]) {\r\n\t\t\ta[s] = v;\r\n\t\t\ts = r + 1; // force to leave the loop\r\n\t\t}\r\n\t\telse {\r\n\t\t\ta[s] = a[t];\r\n\t\t\ts = t;\r\n\t\t}\r\n\t}\r\n\tif (s <= r)\r\n\t\ta[s] = v;\r\n} \r\n\r\nint main() {\r\n\r\n\t// number of elements to sort\r\n\tint n;\r\n\t\r\n\t// array of elements to sort\r\n\tint[] a; \r\n    \r\n    // read data from input\r\n    n = readInt();\r\n    a = new int[n];\r\n    int i = 0;\r\n\twhile (i < a.length) {\r\n\t\ta[i] = readInt();\r\n\t\ti++;\r\n\t}\r\n    \t\r\n    // build heap\r\n    i = (n - 1) / 2;\r\n    while (i >= 0) {\r\n    \tmaxHeapify(a, i, n - 1);\r\n    \ti--;\r\n    }\r\n \r\n \t// sort   \t\r\n    i = n - 1;\r\n    while (i >= 1) {\r\n    \t// swap a[i] and a[0]\r\n    \tint tmp = a[i];\r\n    \ta[i] = a[0];\r\n    \ta[0] = tmp;\r\n    \t\r\n    \tmaxHeapify(a, 0, i - 1);\r\n    \t\r\n    \ti--;\r\n    }\r\n\r\n\t// assert that array is sorted    \r\n\ti = 0;\r\n\twhile (i < n - 1) {\r\n\t\tif (a[i] > a[i + 1])\r\n\t\t\terror();\r\n\t\ti++;\r\n\t}\r\n\t\r\n\t// output sorted array\r\n\tfor (int it : a)\r\n\t\tprintInt(it);\r\n\t\t\r\n\treturn 0;\r\n}\r\n",
      "lista2Kierunkowa.lat": "// autor: Pawel Magryta pm262455\n\n\n\n\n\n\n\n\nint main(){\n\tint dlugoscListy = 30;\n\tlistaTest(dlugoscListy );\n\treturn 0;\n}\n\n\n###### krotki test listy:\n# lista to klasa z publicznymi obiektami bez metod\n\nvoid listaTest(int dlugoscListy){\n\t 30;\n\tLista lista = zwrocListeDlugosci(dlugoscListy);\n\tLista odKonca = przejdzSieNaKoniecIWypisuj(lista, dlugoscListy);\n\tlista = wrocNaPoczatekIWypisuj(odKonca, dlugoscListy);\n\tprintString(\"po spacerku wartosc pierwszego elementu:\");\n\tprintInt(lista.wartosc);\n\tif (dlugoscListy >= 5){\n\t\tLista drugi = lista.nastepny;\n\t\tprintString(\"po spacerku wartosc drugiego elementu:\");\n\t\tprintInt(lista.nastepny.wartosc);\n\t} else {\n\t\treturn;\n\t}\n}\n\n\nLista przejdzSieNaKoniecIWypisuj(Lista start, int dl){\n\tLista a = start, b = start;\n\tprintString(\"idziemy na koniec listy: \");\n\tint i = 0;\n\twhile (i < dl){\n\t\tprintInt(a.wartosc);\n\t\tb = a;\n\t\ta = a.nastepny;\n\t\ti++;\n\t}\n\treturn b;\n}\n\nLista wrocNaPoczatekIWypisuj(Lista odKonca, int dl){\n\tLista a = odKonca, b;\n\tprintString(\"wracamy na poczatek listy: \");\n\tint w = dl;\n\twhile (w > 0){\n\t\tprintInt(a.wartosc);\n\t\tb = a;\n\t\ta = a.poprzedni;\n\t\tw--;\n\t}\n\treturn b;\n}\n\nclass Lista{\n\tLista poprzedni, nastepny;\n\tint wartosc;\n}\n\nLista zwrocListeDlugosci(int dlugoscListy){\n\tprintString(\"Krotki test listy:\");\n\tLista start = new Lista, a, n;\n\ta = start;\n\tint wsk = 1;\n\tstart.wartosc = 0;\n\twhile (wsk != dlugoscListy){\n\t\tstart.poprzedni = null;\n\t\ta.nastepny = new Lista;\n\t\tn = a;\n\t\ta = a.nastepny;\n\t\ta.wartosc = wsk;\n\t\ta.poprzedni = n;\n\t\twsk++;\n\t}\n\ta.nastepny = null;\n\tprintString(\"wygenerowal liste 2kierunkowa dlugosci :\");\n\tprintInt(dlugoscListy);\n\tprintString(\"__________\");\n\treturn start;\n}\n\n\n\n\n",
      "mergeSort.lat": "// autor: Pawel Magryta pm262455\n\n\n\n\n\n\n\n\nint main(){\n\tint dlugoscListy = 30;\n\ttestMergeSort(dlugoscListy);\n\treturn 0;\n}\n\n\n////// merge sort na tablicoListach\n\nvoid testMergeSort(int dlugoscListy){\n\tLista start = generujTablicoListeDoSortowaniaMerge13co7Malejaco(dlugoscListy, true);\n\tLista malejaco = mergeSort(start, 0, dlugoscListy);\n\tprzejdzSieNaKoniecIWypisuj(malejaco, dlugoscListy);\n}\n\nLista mergeSort(Lista start, int pocz, int kon1Za){\n\tLista i1, i2;\n\tif (kon1Za - pocz > 1){\n\t\tint srodek = (kon1Za - pocz) /2 + pocz;\n\t\ti1 = mergeSort(start, pocz, srodek);\n\t\ti2 = mergeSort(start, srodek, kon1Za);\n\t\treturn scalaj(i1, srodek - pocz, i2, kon1Za - srodek);\n\t}\n\tLista n = new Lista;\n\tn.wartosc = pokazWartosc(start, pocz);\n\treturn n;\n}\n\nLista scalaj(Lista lj, int ljLength, Lista ld, int ldLength){\n\tint w1 = 0, w2 = 0, ws = 0;\n\tLista start = generujTablicoListeDoSortowaniaMerge13co7Malejaco(ljLength + ldLength, false);\n\tint wart = pokazWartosc(lj, w1);\n\tint wart2 = pokazWartosc(ld, w2);\n\twhile (ws < ljLength + ldLength){\n\t\tif (w1 == ljLength)\twart = -1;\n\t\telse wart = pokazWartosc(lj, w1);\n\t\tif (w2 == ldLength)\twart2 = -1;\n\t\telse wart2 = pokazWartosc(ld, w2);\n\t\tif (wart2 > wart){\n\t\t\tw2++;\t\t\n\t\t\tladujWartosc(start, ws, wart2);\n\t\t} else{\n\t\t\tw1++;\n\t\t\tladujWartosc(start, ws, wart);\n\t\t}\n\t\tws++;\n\t}\n\treturn start;\n}\n\n//////////////////////////////////\nint pokazWartosc(Lista start, int poz){\n\tint w = 0;\n\tLista a = start;\n\twhile (w != poz) {\n\t\ta = a.nastepny;\n\t\tw++;\n\t}\n\treturn a.wartosc;\n}\nvoid ladujWartosc(Lista start, int poz, int wartosc){\n\tint w = 0;\n\tLista a = start;\n\twhile (w != poz) {\n\t\ta = a.nastepny;\n\t\tw++;\n\t}\n\ta.wartosc = wartosc;\n}\n///////////////////////////////\n\nLista generujTablicoListeDoSortowaniaMerge13co7Malejaco(int dlugoscListy, boolean pisz){\n\tif (pisz) printString(\"robimy liste do mergeSorta:\");\n\tLista start = new Lista, a, n;\n\ta = start;\n\tint wsk = 1;\n\tstart.wartosc = 0;\n\tif (pisz) printInt(start.wartosc);\n\twhile (wsk != dlugoscListy){\n\t\tstart.poprzedni = null;\n\t\ta.nastepny = new Lista;\n\t\tn = a;\n\t\ta = a.nastepny;\n\t\tif (wsk % 5 == 3) a.wartosc = dlugoscListy - wsk / 2;\n\t\telse a.wartosc = wsk % 13;\n\t\t\n\t\ta.poprzedni = n;\n\t\t//a.wartosc = wsk;\n\t\tif (pisz) printInt(a.wartosc);\n\t\twsk++;\n\t}\n\ta.nastepny = null;\n\tif (pisz) printString(\"wygenerowal liste 2kierunkowa dziwna dlugosci :\");\n\tif (pisz) printInt(dlugoscListy);\n\tif (pisz) printString(\"__________\");\n\treturn start;\n}\n\n###### listy\n\nLista przejdzSieNaKoniecIWypisuj(Lista start, int dl){\n\tLista a = start, b = start;\n\tprintString(\"idziemy na koniec listy (ma byc nierosnaco): \");\n\tint wsk = 0;\n\twhile (wsk < dl){\n\t\tprintInt(a.wartosc);\n\t\tb = a;\n\t\ta = a.nastepny;\n\t\twsk++;\n\t}\n\treturn b;\n}\n\nclass Lista{\n\tLista poprzedni, nastepny;\n\tint wartosc;\n}\n\n\n\n"
    },
    "bad": {
      "infinite_loop": {
        "infinite_while.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    while(true) {\n    }\n}\n"
      },
      "runtime": {
        "error.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    error();\n    printInt(1);\n    return 0;\n}\n"
      },
      "semantic": {
        "big_number.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    int i = 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;\n    return 0;\n}\n",
        "declaration_in_if.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    if(true)\n        int a;\n    return 0;\n}\n",
        "declaration_in_if_condition.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    if(int i = 0) {\n    }\n    return 0;\n}\n",
        "declaration_in_while.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    while(true)\n        int a;\n    return 0;\n}\n",
        "function_with_void_argument.lat": "// Author: Jacek Tomaszewski 277663\n// void parameter type\n\nint main() {\n   return 0;\n}\n\nint f(void x) {\n   return 2;\n}",
        "main_with_argument.lat": "// Author: Jacek Tomaszewski 277663\n//main parameter\n\nint main(int y) {\n\treturn 0 ;\n}\n",
        "main_with_void_type.lat": "// Author: Jacek Tomaszewski 277663\n//main void type\n\nvoid main() {\n\treturn 0 ;\n}\n",
        "negation.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    string i;\n    -i;\n    return 0;\n}\n",
        "no_main.lat": "// Author: Tomasz Biczel 277568\nint f() {\n  return 0;\n}",
        "redefined_functions.lat": "// Author: Tomasz Biczel 277568\nint main() {\n  foo();\n  return 0 ;\n}\n\nvoid foo() {\n   printString(\"foo\");\n   return;\n}\n\nint foo(int x) {\n    x = x + 1;\n    return x - 5;\n}\n",
        "redefinition_of_printInt.lat": "// Author: Jacek Tomaszewski 277663\n//redefinition of builtin\n\nint main() {\n   return 0; \n}\n\nvoid printInt(int x) {\n    \n}\n",
        "return_void_result.lat": "/**\n * @author Cezary Bartoszuk <cbart@students.mimuw.edu.pl>\n */\nint main() {\n    return 0;\n}\n\nvoid f() {\n    return g();\n}\n\nvoid g() {\n}",
        "string_decrementation.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    string a;\n    a--;\n    return 0;\n}\n",
        "string_incrementation.lat": "// Author:  Tomasz Wysocki 277696\nint main() {\n    string a;\n    a++;\n    return 0;\n}\n",
        "string_sub.lat": "// Author: Tomasz Biczel 277568\nint main() {\n  string x;\n  x = \"asd\" - \"ewq\";\n  return 0;\n}",
        "undeclared_variable_as_instruction.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    i;\n    return 0;\n}\n",
        "variable_with_void_type.lat": "// Author: Jacek Tomaszewski 277663\n// void variable type\n\nint main() {\n   void x;\n   return 0;\n}\n",
        "while_true_bad_return_type.lat": "// Author: Tomasz Biczel 277568\nint main() {\n    while (true) {\n        string x;\n        x = readString();\n        if (x == \"exit\")\n            return \"asd\";\n        else\n            printString(\"jeszcze raz\");\n    }\n}"
      }
    },
    "good": {
      "arrays": {
        "array_length.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    printInt((new int[1]).length);\n    return 0;\n}\n",
        "array_new.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    string[] a = new string[1];\n    return 0;\n}\n",
        "array_read.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    (new int[1])[0];\n    return 0;\n}\n",
        "array_string.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    string[] a = new string[1];\n    a[0] = \"abc\";\n    printString(a[0]);\n    return 0;\n}\n",
        "heapsort.lat": "// Program zaliczeniowy 3: \"tablice - heap sort\"\n// autor: Bolek Kulbabinski\n//   Wejscie: dlugosc tablicy n > 0 po czym n liczb calkowitych.\n//   Wyjscie: n liczb w kolejnosci niemalejacej\n\nvoid swap(int[] tab, int x, int y) {\n    int temp = tab[x];\n    tab[x] = tab[y];\n    tab[y] = temp;\n}\n\n// Poprawienie kopca typu max.\nvoid heapDown(int[] heap, int index, int heapSize) {\n    while (index * 2 < heapSize - 1) {\n        int left = index * 2 + 1;\n        int right = left + 1;\n        int max = left;\n        if (right < heapSize && heap[right] > heap[max]) {\n            max = right;\n        }\n        if (heap[max] > heap[index]) {\n            swap(heap, max, index);\n            index = max;\n        } else {\n            return;\n        }\n    }\n}\n\nint extractMax(int[] heap, int heapSize) {\n    int max = heap[0];\n    heap[0] = heap[heapSize - 1];\n    heapDown(heap, 0, heapSize - 1);\n    return max;\n}\n\nvoid heapSort(int[] heap) {\n    // Budowanie kopca.\n    int i = heap.length / 2;\n    while (i >= 0) {\n        heapDown(heap, i, heap.length);\n        i--;\n    }\n\n    // Sortowanie.\n    i = heap.length - 1;\n    while (i >= 0) {\n        heap[i] = extractMax(heap, i + 1);\n        i--;\n    }\n}\n\nint main() {\n    int n = readInt();\n    int[] tab = new int[n];\n\n    int i = 0;\n    while (i < n) {\n        tab[i] = readInt();\n        i++;\n    }\n\n    heapSort(tab);\n\n    for (int elem : tab) {\n        printInt(elem);\n    }\n\n    return 0;\n}\n\n"
      },
      "basic": {
        "add.lat": "// Author: Tomasz Wysocki 277696\n\nint main() {\n    printInt(1 + 1);\n    return 0;\n}\n",
        "bool_operations.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    b(t(1) && f(2));\n    b(t(3) && t(4));\n    b(t(5) || t(6));\n    b(f(7) && t(8));\n    b(t(9) && t(10) && t(11));\n    b(f(12) || f(13) && t(14));\n    return 0;\n}\n\nboolean f(int a) {\n    printInt(a);\n    return false;\n}\nboolean t(int a) {\n    return !f(a);\n}\nvoid b(boolean a) {\n    if(a)\n        printString(\"true\");\n    else\n        printString(\"false\");\n}\n",
        "bool_overoptymization.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    print() && false;\n    return 0;\n}\n\nboolean print() {\n    printString(\"ahoj\");\n    return true;\n}\n",
        "compare.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    if(1 <= 1)\n        printString(\"4\");\n    if(1 >= 1)\n        printString(\"4\");\n    if(1 > 1)\n        printString(\"5\");\n    if(1 < 1)\n        printString(\"5\");\n    if(1 < 2)\n        printString(\"6\");\n    if(2 > 1)\n        printString(\"6\");\n    if(1 > 2)\n        printString(\"7\");\n    if(2 < 1)\n        printString(\"7\");\n    return 0;\n}\n",
        "concatenation.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    printString(\"a\" + \"b\");\n    return 0;\n}\n",
        "empty_if.lat": "// Author: Tomasz Wysocki 277696\n\nint main() {\n    if(false);\n    printInt(1);\n    return 0;\n}\n",
        "empty_instructions.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    ;;;;;\n    return 0;\n}\n",
        "empty_while.lat": "// Author: Tomasz Wysocki 277696\n\nint main() {\n    while(false);\n    printInt(1);\n    return 0;\n}\n",
        "escaped_string.lat": "// Autor: Bolek Kulbabinski\n\nint f(int p){\n    int c = p + 2*p;\n    printString(\"\\\"\\npop\\npowrot:\\ngetstatic java/lang/System/out Ljava/io/PrintStream;\\nldc \\\"zle \\\"\\ninvokevirtual java/io/PrintStream/print(Ljava/lang/String;)V\\ngoto powrot\\nldc \\\"\");\n    return c;\n}\n\nint main() {\n    return f(1) - 3;\n}\n\n",
        "fibonacci.lat": "/**\n * Iterative fibonacci.\n *\n * @param n a non-negative index in Fibonacci sequence.\n * @return value of `n`'th Fibonacci number\n *\n * @author cbart@students.mimuw.edu.pl (Cezary Bartoszuk)\n */\nint fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    int fib_a = 0;\n    int fib_b = 1;\n    int tmp;\n    int i = 2;\n    while (i <= n) {\n        tmp = fib_b + fib_a;\n        fib_a = fib_b;\n        fib_b = tmp;\n        i++;\n    }\n    return fib_b;\n}\n\n\nint main() {\n    int i = readInt();\n    if (i >= 0) {\n        printInt(fibonacci(i));\n        return 0;\n    } else {\n        printString(\"Expected a non-negative integer, but got:\");\n        printInt(i);\n        return 1;\n    }\n}\n",
        "fine_ident.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    int abcABC000___ = 0;\n    return abcABC000___;\n}\n",
        "mod.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    printInt(5 % 3);\n    printInt(-5 % 3); // -2 - sic!\n    return 0;\n}\n",
        "negation.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    printInt(- -1);\n    int i = 1;\n    printInt(-i);\n    printInt(2 - -i);\n    return 0;\n}\n",
        "print_complicated_string.lat": "// Autor: Tomasz Wysocki 277696\nint main() {\n    printString(\"\\\\a\\\\n\\n\\tb\\\"\");\n    return 0;\n}\n",
        "print_int.lat": "// Autor: Tomasz Wysocki 277696\nint main() {\n    printInt(1);\n    return 0;\n}\n",
        "print_string.lat": "// Autor: Tomasz Wysocki 277696\nint main() {\n    printString(\"abc\");\n    return 0;\n}\n",
        "scopes.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    int i = 0;\n    printInt(i);\n    {\n        int i = 1;\n        printInt(i);\n    }\n    printInt(i);\n    {\n        int i = 2;\n        printInt(i);\n    }\n    printInt(i);\n    return 0;\n}\n",
        "void_return.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    run();\n    return 0;\n}\n\nvoid run() {\n    printInt(0);\n    if(true)\n        return;\n}\n",
        "while_true.lat": "// Author: Tomasz Wysocki 277696\nint main() {\n    while(true) {\n        return 0;\n    }\n}\n",
        "while_true2.lat": "// Author: Tomasz Biczel 277568, Tomasz Wysocki 277696\nint main() {\n    while (true) {\n        int x;\n        x = readInt();\n        if (x == 1)\n            return 0;\n        else\n            printString(\"jeszcze raz\");\n    }\n\n    return 0;\n}\n"
      },
      "hardcore": {
        "big_string.lat": "// Author: Tomasz Wysocki 277696\n//\n// Zajmuje około 15Gb pamięci, jeśli nie masz żadnego odśmiecania.\n//\n// UWAGA: Jeśli masz swap, może porządnie zamulić komputer.\nint main() {\n    string s1 = \"\";\n    string s2 = \"\";\n    int i = 0;\n    while(i < 1024 * 100) {\n        s1 = s1 + \"a\";\n        if(i % 2 == 0)\n            s2 = s2 + \"a\";\n        i++;\n    }\n    printString(\"Done\");\n    return 0;\n}\n",
        "tail_call_optymization.lat": "// Author: Tomasz Wysocki 277696\n\n// 1000000 stopni rekursji powinno wysypać każdy program.\n// Aby przejść ten test trzeba mieć optymalizację, która\n// zamienia rekurencję ogonową na pętlę.\nint main() {\n    printInt(sum(1000000, 0));\n    return 0;\n}\nint sum(int z, int a) {\n    if(z == 0)\n        return a;\n    int y = z;\n    if(y % 2 == 1)\n        y = -1 * z;\n    return sum(z-1, a+y);\n}\n"
      },
      "virtual": {
        "polymorphism.lat": "// autor: Bolek Kulbabinski\n\nclass A {\n    void print() {\n        printString(\"A\");\n    }\n}\n\nclass B extends A {\n    void print() {\n        printString(\"B\");\n    }\n}\n\nclass C extends B {\n    void print() {\n        printString(\"C\");\n    }\n}\n\nclass D extends C {\n    void print() {\n        printString(\"D\");\n    }\n}\n\n\n\nB fun(){\n    // Return z podtypem.\n    return new C;\n}\n\nA fun2(B param){\n    return param;\n}\n\nint main(){\n    // Inicjalizacja podtypem.\n    A z1 = new B;\n    z1.print();\n    A z2 = fun();\n    z2.print();\n\n    // Przypisanie podtypu.\n    z2 = new B;\n    z2.print();\n\n    // Przekazanie podtypu jako parametr.\n    A z3 = fun2(new C);\n    z3.print();\n\n    // Nadtyp w for-each (dla tablic obiektow).\n    C[] tab;\n    tab  = new C[3];\n    tab[0] = new C;\n    tab[1] = new D;\n    tab[2] = new D;\n    for (B elem : tab) {\n        fun2(elem).print();\n    }\n\n    // Porownywanie z podtypem.\n    B t1 = new B;\n    A t2 = t1;\n\n    if (t1 == t2) {\n        printString(\"tak\");\n    }\n    if (t1 != t2) {\n        printString(\"nie\");\n    }\n\n    return 0;\n}\n"
      }
    }
  }
}
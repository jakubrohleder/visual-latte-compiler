var exports = module.exports = {};

exports.compile = compile;

function compile(program, className) {
  var code;
  var compiled = _compile(program);

  code = generateHeader(className, 1, 1);
  code += generateMain(compiled);

  return code;
}



function _compile(program) {
  var compiled = {
    code: [],
    locals: program.locals,
    stack: 0
  }
  var env = program.env;

  for (var i = 0; i < program.lines.length; i++) {
    var line = compileNode(program.lines[i]);
    compiled.code.push('.line ' + (i+1));
    compiled.code.push(line.code);
    compiled.stack = line.stack > compiled.stack ? line.stack : compiled.stack;
  }

  return compiled;

  function compileNode(node) {
    var code = [];
    var left;
    var right;

    if (node.nodeType === 'stmt') {
      right = compileNode(node.right);
      code = code.concat(right.code);
      code.push('istore ' + env[node.left.value].index);
    } else if (node.nodeType === 'exp') {
      if (node.value === '+' || node.value === '*') {
        left = compileNode(node.left);
        right = compileNode(node.right);

        if (node.left.height > node.right.height) {
          code = code.concat(left.code);
          code = code.concat(right.code);
        } else {
          code = code.concat(right.code);
          code = code.concat(left.code);
        }
      } else if (node.value === '-' || node.value === '/') {
        left = compileNode(node.left);
        right = compileNode(node.right);

        code = code.concat(left.code);
        code = code.concat(right.code);
      }

      if (node.value === '-') {
        code.push('isub');
      } else if (node.value === '/') {
        code.push('idiv');
      } else if (node.value === '*') {
        code.push('imul');
      } else if (node.value === '+') {
        code.push('iadd');
      }

    } else if (node.nodeType === 'string') {
      code.push('iload ' + env[node.value].index);
    } else if (node.nodeType === 'number') {
      code.push('bipush ' + node.value);
    }

    return {
      code: code,
      stack: 0
    };
  }
}

function generateHeader(className) {
  var header = '';

  header += '; ' + className.toLowerCase() + '.j\n';
  header += '; Generated by visual-compiler Â®Jakub Rohleder\n';
  header += '; Analyzer and Disassembler for Java class files\n';
  header += '; (Jasmin syntax 2, http://jasmin.sourceforge.net)\n\n';

  header += '.bytecode 52.0\n';
  header += '.class public ' + className + '\n';
  header += '.super java/lang/Object';

  header += '.method public <init>()V\n';
  header += '  .limit stack 1\n';
  header += '  .limit locals 1\n';
  header += '  .line 1\n';
  header += '  0: aload_0\n';
  header += '  1: invokespecial java/lang/Object/<init>()V\n';
  header += '  4: return\n';
  header += '.end method\n\n';

  return header;
}

function generateMain(compiled) {
  var main = '';

  main += '.method public static main([Ljava/lang/String;)V\n';
  main += '  .limit stack ' + compiled.stack + '\n';
  main += '  .limit locals ' + compiled.locals + '\n';

  main += indentLines(compiled.code, 1).join('\n');

  main += '\n.end method\n';

  return main;
}

function indentLines(array, indentation) {
  indentation = indentation === undefined ? 0 : indentation;
  return array.reduce(reduce, []);

  function reduce(accumulator, element) {
    if (element instanceof Array) {
      var tmp = indentLines(element, indentation + 1);
      return accumulator.concat(tmp);
    } else {
      var indent = new Array(indentation + 1).join('  ');
      accumulator.push(indent + element);
      return accumulator;
    }
  }
}
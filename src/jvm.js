var exports = module.exports = {};

exports.compile = compile;

function compile(program, className) {
  var compiled = _compile(program);

  compiled.code = generateHeader(className);
  compiled.code += generateMain(compiled);

  return compiled;
}



function _compile(program) {
  var compiled = {
    mainCode: [],
    locals: program.locals,
    stack: 0
  }
  var env = program.env;
  var currentStack = 0;

  for (var i = 0; i < program.lines.length; i++) {
    var line = compileNode(program.lines[i]);

    while(currentStack > 0) {
      currentStack--;
      line.push('pop');
    }

    compiled.mainCode.push('.line ' + (i+1));
    compiled.mainCode.push(line);
  }

  return compiled;

  function compileNode(node) {
    var code = [];
    var right;

    if (node.nodeType === 'stmt') {
      right = compileNode(node.right);
      code = code.concat(right);
      code.push('istore ' + env[node.left.value].index);
      currentStack--;
    } else if (node.nodeType === 'exp') {
      if (node.left.height >= node.right.height) {
        code = code.concat(compileNode(node.left));
        code = code.concat(compileNode(node.right));
      } else {
        code = code.concat(compileNode(node.right));
        code = code.concat(compileNode(node.left));
        if (node.value === '-' || node.value === '/') {
          code.push('swap');
        }
      }

      if (node.value === '-') {
        code.push('isub');
      } else if (node.value === '/') {
        code.push('idiv');
      } else if (node.value === '*') {
        code.push('imul');
      } else if (node.value === '+') {
        code.push('iadd');
      }

      currentStack--;
    } else if (node.nodeType === 'string') {
      code.push('iload ' + env[node.value].index);
      currentStack++;
    } else if (node.nodeType === 'number') {
      code.push('bipush ' + node.value);
      currentStack++;
    }

    compiled.stack = currentStack > compiled.stack ? currentStack : compiled.stack;
    return code;
  }
}

function generateHeader(className) {
  var header = '';

  header += '; Generated by visual-compiler Â®Jakub Rohleder\n';
  header += '; https://github.com/jakubrohleder/visual-compiler\n';
  header += '; (Jasmin syntax 2, http://jasmin.sourceforge.net)\n\n';

  header += '.bytecode 52.0\n'
  header += '.class public ' + className + '\n';
  header += '.super java/lang/Object\n\n';

  header += '.method public <init>()V\n';
  header += '  .limit stack 1\n';
  header += '  .limit locals 1\n';
  header += '  .line 1\n';
  header += '  0: aload_0\n';
  header += '  1: invokespecial java/lang/Object/<init>()V\n';
  header += '  4: return\n';
  header += '.end method\n\n';

  return header;
}

function generateMain(compiled) {
  var main = '';

  main += '.method public static main([Ljava/lang/String;)V\n';
  main += '  .limit stack ' + compiled.stack + '\n';
  main += '  .limit locals ' + compiled.locals + '\n';

  main += indentLines(compiled.mainCode, 1).join('\n');

  main += '\n.end method\n';

  return main;
}

function indentLines(array, indentation) {
  indentation = indentation === undefined ? 0 : indentation;
  return array.reduce(reduce, []);

  function reduce(accumulator, element) {
    if (element instanceof Array) {
      var tmp = indentLines(element, indentation + 1);
      return accumulator.concat(tmp);
    } else {
      var indent = new Array(indentation + 1).join('  ');
      accumulator.push(indent + element);
      return accumulator;
    }
  }
}